#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sim_converter.h"

int main(int argc, char *argv[]) {

    FILE *input_file;

    if (argc != 2) {
        input_file = fopen("../simulation_results/radar_MANPADS_engagement_output_messages.txt", "r");
    } else {
        input_file = fopen(argv[1], "r");
    }

    if (input_file == NULL) {
        printf("\n File could not be opened.");
        return -1;
    }

    FILE *output_file;
    output_file = fopen("../simulation_results/stk_connect_commands.txt", "w");

    /* STK Connect command to create a new scenario */
    fprintf(output_file, "New / Scenario %s\n", SCENARIO_NAME);

    /* STK Connect command to set the scenario epoch */
    fprintf(output_file, "SetEpoch * \"%s 00:00:00.00\"\n", SCENARIO_DATE);

    /* Retrieve all atomic models instances */
    char *start_extract_model = "generated by model ";

    while (!feof(input_file)) {
        char line_text[MAX_LINE_LENGTH] = {'\0'};
        char model_name[MAX_MODEL_LENGTH] = {'\0'};
        char *p_start_extract = NULL;
        char *p_end_extract = NULL;
        int count_characters = 0;

        fgets(line_text, sizeof(line_text), input_file);
        p_start_extract = strstr(line_text, start_extract_model);

        if (p_start_extract == NULL) {
            continue;
        }

        p_end_extract = strchr(line_text, '\n');

        if (p_end_extract == NULL) {
            continue;
        }

        count_characters = p_end_extract - p_start_extract - strlen(start_extract_model);
        strncpy(model_name, p_start_extract + strlen(start_extract_model), count_characters);

        add_model(model_name);

    }

    /* Retrieve all output ports */
    char *start_extract_output_port = "defs::";
    char *end_extract_output_port = ": {";

    fseek(input_file, 0, SEEK_SET);
    while (!feof(input_file)) {
        char line_text_2[MAX_LINE_LENGTH] = {'\0'};
        char output_port_name[MAX_MODEL_LENGTH] = {'\0'};
        char *p_start_extract_output_port = NULL;
        char *p_end_extract_output_port = NULL;
        char *p_start_extract_3 = NULL;
        char *p_end_extract_3 = NULL;
        int count_characters = 0;

        fgets(line_text_2, sizeof(line_text_2), input_file);
        p_start_extract_output_port = strstr(line_text_2, start_extract_output_port);

        if (p_start_extract_output_port == NULL) {
            continue;
        }

        p_end_extract_output_port = strstr(line_text_2, end_extract_output_port);

        if (p_end_extract_output_port == NULL) {
            continue;
        }

        count_characters = p_end_extract_output_port - p_start_extract_output_port - strlen(start_extract_output_port);
        strncpy(output_port_name, p_start_extract_output_port + strlen(start_extract_output_port), count_characters);
        add_output_port(output_port_name);

        if (strstr(p_end_extract_output_port, start_extract_output_port) != NULL) {
            char second_output_port_name[MAX_MODEL_LENGTH] = {'\0'};
            p_start_extract_3 = strstr(p_end_extract_output_port, start_extract_output_port);
            p_end_extract_3 = strstr(p_start_extract_3, end_extract_output_port);
            count_characters = p_end_extract_3 - p_start_extract_3 - strlen(start_extract_output_port);
            strncpy(second_output_port_name, p_start_extract_3 + strlen(start_extract_output_port), count_characters);
            add_output_port(second_output_port_name);
        }
    }

    char search_model[MAX_MODEL_LENGTH] = {'\0'};
    char search_model_line[MAX_MODEL_LENGTH] = {'\0'};
    char search_output_port[MAX_MODEL_LENGTH] = {'\0'};
    char time[MAX_LINE_LENGTH] = {'\0'};
    char next_time[MAX_LINE_LENGTH] = {'\0'};
    const char start_extract_position = '<';
    const char end_extract_position = '>';
    const char delimiter[2] = ",";
    char *start_extract_range = "range: ";
    char *end_extract_range = " m |";
    char *p_start_extract_range = {'\0'};
    char *p_end_extract_range = {'\0'};

    model_t *current_model = model_head;

    /* Looping through all model instances in the linked-list */
    while (current_model != NULL) {

        strcpy(search_model, current_model->name);
        sprintf(search_model_line, "%s%s", start_extract_model, search_model);

        output_port_t *current_output_port = output_port_head;

        /* Looping through all output ports in the linked-list */
        while (current_output_port != NULL) {
            strcpy(search_output_port, current_output_port->name);

            int n = 0;
            int m = 0;
            int o = 0;

            fseek(input_file, 0, SEEK_SET);

            /* Looping through each line */
            while (!feof(input_file)) {
                char *start_extract = NULL;
                char *end_extract = NULL;
                char position[50] = {'\0'};
                char range[50] = {'\0'};
                char position_lat_long_alt[3][50];
                int count_characters = 0;
                char line_text[MAX_LINE_LENGTH] = {'\0'};

                fgets(line_text, sizeof(line_text), input_file);

                /* Checks if the line contains a simulation (e.g. 00:00:04:000) */
                if ((line_text[0] != '[') && (line_text[0] != '\0')) {
                    memset(time, '\0', sizeof(time));
                    memset(next_time, '\0', sizeof(next_time));
                    strncpy(time, line_text, 8);
                    strcpy(next_time, time);
                    strcat(next_time, ".999");
                    strcat(time, ".000");

                    /* Checks if the line contains the model, the output port, a position, an altitude and if it the
                     * first DEVS output for the model instance */
                } else if (strstr(line_text, search_model_line) != NULL &&
                           strstr(line_text, search_output_port) != NULL &&
                           strstr(line_text, "altitude") != NULL &&
                           n == 0 && strchr(line_text, '<') != NULL) {

                    n++;

                    /* Get position information */
                    start_extract = strrchr(line_text, start_extract_position);
                    end_extract = strrchr(line_text, end_extract_position);
                    count_characters = end_extract - start_extract;
                    strncpy(position, start_extract + 1, count_characters - 1);
                    char *token = strtok(position, delimiter);
                    int i = 0;
                    while (token != NULL) {
                        strcpy(position_lat_long_alt[i], token);
                        token = strtok(NULL, delimiter);
                        i++;
                    }

                    /* STK Connect commands */
                    fprintf(output_file, "New / */Aircraft %s\n", search_model);
                    fprintf(output_file, "VO */Aircraft/%s Model File \"helicopter.mdl\"\n", search_model);
                    fprintf(output_file, "New / */Aircraft/%s/Receiver in_port\n", search_model);
                    fprintf(output_file, "SetConstraint */Aircraft/%s/Receiver/in_port LineOfSight Off\n",
                            search_model);
                    fprintf(output_file, "AddWaypoint */Aircraft/%s DetVelFromTime %s %s %s \"%s %s\"\n", search_model,
                            position_lat_long_alt[0], position_lat_long_alt[1], position_lat_long_alt[2], SCENARIO_DATE,
                            time);

                    /* Checks if the line contains the model, the output port, a position, an altitude and if it is NOT
                     * the first DEVS output for the model instance */
                } else if (strstr(line_text, search_model_line) != NULL &&
                           strstr(line_text, search_output_port) != NULL &&
                           strstr(line_text, "altitude") != NULL &&
                           n > 0 &&
                           strchr(line_text, '<') != NULL) {

                    /* Get position information */
                    start_extract = strrchr(line_text, start_extract_position);
                    end_extract = strrchr(line_text, end_extract_position);
                    count_characters = end_extract - start_extract;
                    strncpy(position, start_extract + 1, count_characters - 1);
                    char *token = strtok(position, delimiter);
                    int i = 0;
                    while (token != NULL) {
                        strcpy(position_lat_long_alt[i], token);
                        token = strtok(NULL, delimiter);
                        i++;
                    }

                    /* STK Connect commands */
                    fprintf(output_file, "AddWaypoint */Aircraft/%s DetVelFromTime %s %s %s \"%s %s\"\n",
                            search_model, position_lat_long_alt[0], position_lat_long_alt[1], position_lat_long_alt[2],
                            SCENARIO_DATE,
                            time);

                    /* Checks if the line contains the model, the output port, a position, NO altitude, a range and if it is
                     * the first DEVS output for the model instance */
                } else if (strstr(line_text, search_model_line) != NULL &&
                           strstr(line_text, search_output_port) != NULL &&
                           strstr(line_text, "altitude") == NULL &&
                           strstr(line_text, "range") != NULL &&
                           m == 0 &&
                           strchr(line_text, '<') != NULL) {
                    m++;

                    /* Get range information */
                    p_start_extract_range = strstr(line_text, start_extract_range);
                    p_end_extract_range = strstr(line_text, end_extract_range);
                    count_characters = p_end_extract_range - p_start_extract_range - strlen(start_extract_range);
                    strncpy(range, p_start_extract_range + strlen(start_extract_range), count_characters);

                    /* Get position information */
                    start_extract = strrchr(line_text, start_extract_position);
                    end_extract = strrchr(line_text, end_extract_position);
                    count_characters = end_extract - start_extract;
                    strncpy(position, start_extract + 1, count_characters - 1);
                    char *lat = strtok(position, ",");
                    char *lon = strtok(NULL, ",");

                    /* STK Connect commands */
                    fprintf(output_file, "New / */Facility %s\n", search_model);
                    fprintf(output_file, "New / */Facility/%s/Receiver in_port\n", search_model);
                    fprintf(output_file, "SetConstraint */Facility/%s/Receiver/in_port LineOfSight Off\n",
                            search_model);
                    fprintf(output_file, "SetPosition */Facility/%s Geodetic %s %s Terrain\n", search_model, lat, lon);
                    fprintf(output_file, "New / */Facility/%s/Transmitter %s\n", search_model, search_output_port);
                    fprintf(output_file, "SetConstraint */Facility/%s/Transmitter/%s LineOfSight Off\n", search_model,
                            search_output_port);
                    fprintf(output_file,
                            "SetConstraint */Facility/%s/Transmitter/%s Intervals Include SetIntervals Add 1 \"%s %s\" \"%s %s\"\n",
                            search_model, search_output_port, SCENARIO_DATE, time, SCENARIO_DATE, next_time);
                    fprintf(output_file, "New / */Facility/%s/Sensor range\n", search_model);
                    fprintf(output_file, "Define */Facility/%s/Sensor/range SimpleCone 90.0\n", search_model);
                    fprintf(output_file, "SetConstraint */Facility/%s/Sensor/range Range Max %s\n", search_model,
                            range);


                    /* Checks if the line contains the model, the output port, a position, NO altitude, a range and if it is NOT
                     * the first DEVS output for the model instance */
                } else if (strstr(line_text, search_model_line) != NULL &&
                           strstr(line_text, search_output_port) != NULL &&
                           strstr(line_text, "altitude") == NULL &&
                           strstr(line_text, "range") == NULL &&
                           o == 0 &&
                           strchr(line_text, '<') != NULL) {
                    o++;

                    /* Get position information */
                    start_extract = strrchr(line_text, start_extract_position);
                    end_extract = strrchr(line_text, end_extract_position);
                    count_characters = end_extract - start_extract;
                    strncpy(position, start_extract + 1, count_characters - 1);
                    char *lat = strtok(position, ",");
                    char *lon = strtok(NULL, ",");

                    /* STK Connect commands */
                    fprintf(output_file, "New / */Facility %s\n", search_model);
                    fprintf(output_file, "New / */Facility/%s/Receiver in_port\n", search_model);
                    fprintf(output_file, "SetConstraint */Facility/%s/Receiver/in_port LineOfSight Off\n",
                            search_model);
                    fprintf(output_file, "SetPosition */Facility/%s Geodetic %s %s Terrain\n", search_model, lat, lon);
                    fprintf(output_file, "New / */Facility/%s/Transmitter %s\n", search_model, search_output_port);
                    fprintf(output_file,
                            "SetConstraint */Facility/%s/Transmitter/%s Intervals Include SetIntervals Add 1 \"%s %s\" \"%s %s\"\n",
                            search_model, search_output_port, SCENARIO_DATE, time, SCENARIO_DATE, next_time);
                    fprintf(output_file, "SetConstraint */Facility/%s/Transmitter/%s LineOfSight Off\n", search_model,
                            search_output_port);


                } else if (strstr(line_text, search_model_line) != NULL &&
                           strstr(line_text, search_output_port) != NULL &&
                           strstr(line_text, "altitude") == NULL && m > 0 &&
                           strchr(line_text, '<') != NULL) {

                    /* STK Connect commands */
                    fprintf(output_file,
                            "SetConstraint */Facility/%s/Transmitter/%s Intervals Include SetIntervals Add 1 \"%s %s\" \"%s %s\"\n",
                            search_model, search_output_port, SCENARIO_DATE, time, SCENARIO_DATE, next_time);

                } else if (strstr(line_text, search_model_line) != NULL &&
                           strstr(line_text, search_output_port) != NULL &&
                           strstr(line_text, "altitude") == NULL && o > 0 &&
                           strchr(line_text, '<') != NULL) {

                    /* STK Connect commands */
                    fprintf(output_file,
                            "SetConstraint */Facility/%s/Transmitter/%s Intervals Include SetIntervals Add 1 \"%s %s\" \"%s %s\"\n",
                            search_model, search_output_port, SCENARIO_DATE, time, SCENARIO_DATE, next_time);

                } else {
                    continue;
                }
            }
            current_output_port = current_output_port->next;
        }
        current_model = current_model->next;
    }

    /* STK Connect commands */
    fprintf(output_file, "SetAnalysisTimePeriod * \"%s 00:00:00.00\" \"%s %s\"\n", SCENARIO_DATE, SCENARIO_DATE, time);
    fprintf(output_file, "SetAnimation * StartAndCurrentTime UseAnalysisStartTime TimeStep 1\n");

    /* STK Connect commands to compute access between input and output ports
     * These commands are specific to the radar-augmented MANPADS engagement model */
    fprintf(output_file,
            "Access */Facility/c2/Transmitter/outOrder */Facility/gunner1/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/c2/Transmitter/outOrder */Facility/gunner2/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/c2/Transmitter/outOrder */Facility/gunner3/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/gunner1/Transmitter/outGunnerStatus */Facility/c2/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/gunner2/Transmitter/outGunnerStatus */Facility/c2/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/gunner3/Transmitter/outGunnerStatus */Facility/c2/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/missile1/Transmitter/outMissileStatus */Aircraft/aircraft/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/missile2/Transmitter/outMissileStatus */Aircraft/aircraft/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/missile3/Transmitter/outMissileStatus */Aircraft/aircraft/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/missile1/Transmitter/outMissileStatus */Facility/c2/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/missile2/Transmitter/outMissileStatus */Facility/c2/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/missile3/Transmitter/outMissileStatus */Facility/c2/Receiver/in_port AutoAddTimeline on\n");
    fprintf(output_file,
            "Access */Facility/radar/Transmitter/outDetectedPosition */Facility/c2/Receiver/in_port AutoAddTimeline on\n");

    printf("\n Conversion completed. \n");

    fclose(output_file);
    fclose(input_file);
    return 0;
}

void add_model(char *model_id) {
    if (model_head == NULL) {
        model_t *new_model = (model_t *) malloc(sizeof(model_t));
        if (new_model == NULL) {
            return;
        } else {
            strcpy(new_model->name, model_id);
            new_model->next = model_head;
            model_head = new_model;
        }
    } else {
        model_t *current = model_head;
        while (current != NULL) {
            if (strcmp(current->name, model_id) == 0) {
                return;
            } else {
                current = current->next;
            }
        }

        /* Add model at the end if not found in the list */
        model_t *last = model_head;
        while (last->next != NULL) {
            last = last->next;
        }
        last->next = (model_t *) malloc(sizeof(model_t));
        strcpy(last->next->name, model_id);
        last->next->next = NULL;
    }
}

void add_output_port(char *output_port_id) {
    if (output_port_head == NULL) {
        output_port_t *new_model = (output_port_t *) malloc(sizeof(output_port_t));
        if (new_model == NULL) {
            return;
        } else {
            strcpy(new_model->name, output_port_id);
            new_model->next = output_port_head;
            output_port_head = new_model;
        }
    } else {
        output_port_t *current = output_port_head;
        while (current != NULL) {
            if (strcmp(current->name, output_port_id) == 0) {
                return;
            } else {
                current = current->next;
            }
        }

        /* Add output port at the end if not found in the list */
        output_port_t *last = output_port_head;
        while (last->next != NULL) {
            last = last->next;
        }
        last->next = (output_port_t *) malloc(sizeof(output_port_t));
        strcpy(last->next->name, output_port_id);
        last->next->next = NULL;
    }
}